<<<<<<< HEAD
'use strict';
=======
"use strict";
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f

Object.defineProperty(exports, "__esModule", {
  value: true
});
<<<<<<< HEAD

var _isSimpleType = require('./isSimpleType');

var _isSimpleType2 = _interopRequireDefault(_isSimpleType);

var _needWrap = require('./needWrap');

var _needWrap2 = _interopRequireDefault(_needWrap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var schema = [{
=======
exports.default = void 0;

var _isSimpleType = _interopRequireDefault(require("./isSimpleType"));

var _needWrap = _interopRequireDefault(require("./needWrap"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const schema = [{
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
  enum: ['verbose', 'shorthand'],
  type: 'string'
}];

<<<<<<< HEAD
var inlineType = function inlineType(type) {
  var inlined = type.replace(/\s+/g, ' ');
=======
const inlineType = type => {
  const inlined = type.replace(/\s+/g, ' ');
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f

  if (inlined.length <= 50) {
    return inlined;
  } else {
    return 'Type';
  }
};

<<<<<<< HEAD
exports.default = function (defaultConfig, simpleType) {
  var create = function create(context) {
    var verbose = (context.options[0] || defaultConfig) === 'verbose';

    return {
      // shorthand
      ArrayTypeAnnotation(node) {
        var rawElementType = context.getSourceCode().getText(node.elementType);
        var inlinedType = inlineType(rawElementType);
        var wrappedInlinedType = (0, _needWrap2.default)(node.elementType) ? '(' + inlinedType + ')' : inlinedType;

        if ((0, _isSimpleType2.default)(node.elementType) === simpleType && verbose) {
=======
var _default = (defaultConfig, simpleType) => {
  const create = context => {
    const verbose = (context.options[0] || defaultConfig) === 'verbose';
    return {
      // shorthand
      ArrayTypeAnnotation(node) {
        const rawElementType = context.getSourceCode().getText(node.elementType);
        const inlinedType = inlineType(rawElementType);
        const wrappedInlinedType = (0, _needWrap.default)(node.elementType) ? '(' + inlinedType + ')' : inlinedType;

        if ((0, _isSimpleType.default)(node.elementType) === simpleType && verbose) {
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
          context.report({
            data: {
              type: inlinedType,
              wrappedType: wrappedInlinedType
            },
<<<<<<< HEAD
            fix(fixer) {
              return fixer.replaceText(node, 'Array<' + rawElementType + '>');
            },
=======

            fix(fixer) {
              return fixer.replaceText(node, 'Array<' + rawElementType + '>');
            },

>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
            message: 'Use "Array<{{ type }}>", not "{{ wrappedType }}[]"',
            node
          });
        }
      },

      // verbose
      GenericTypeAnnotation(node) {
        if (node.id.name === 'Array') {
          // Don't report on un-parameterized Array annotations. There are valid cases for this,
          // but regardless, we should not crash when encountering them.
          if (node.typeParameters && node.typeParameters.params.length === 1) {
<<<<<<< HEAD
            var elementTypeNode = node.typeParameters.params[0];
            var rawElementType = context.getSourceCode().getText(elementTypeNode);
            var inlinedType = inlineType(rawElementType);
            var wrappedInlinedType = (0, _needWrap2.default)(elementTypeNode) ? '(' + inlinedType + ')' : inlinedType;

            if ((0, _isSimpleType2.default)(elementTypeNode) === simpleType && !verbose) {
=======
            const elementTypeNode = node.typeParameters.params[0];
            const rawElementType = context.getSourceCode().getText(elementTypeNode);
            const inlinedType = inlineType(rawElementType);
            const wrappedInlinedType = (0, _needWrap.default)(elementTypeNode) ? '(' + inlinedType + ')' : inlinedType;

            if ((0, _isSimpleType.default)(elementTypeNode) === simpleType && !verbose) {
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
              context.report({
                data: {
                  type: inlinedType,
                  wrappedType: wrappedInlinedType
                },
<<<<<<< HEAD
                fix(fixer) {
                  if ((0, _needWrap2.default)(elementTypeNode)) {
=======

                fix(fixer) {
                  if ((0, _needWrap.default)(elementTypeNode)) {
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
                    return fixer.replaceText(node, '(' + rawElementType + ')[]');
                  } else {
                    return fixer.replaceText(node, rawElementType + '[]');
                  }
                },
<<<<<<< HEAD
=======

>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
                message: 'Use "{{ wrappedType }}[]", not "Array<{{ type }}>"',
                node
              });
            }
          }
        }
      }
<<<<<<< HEAD
=======

>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    };
  };

  return {
    create,
<<<<<<< HEAD
=======
    meta: {
      fixable: 'code'
    },
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    schema
  };
};

<<<<<<< HEAD
=======
exports.default = _default;
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
module.exports = exports.default;