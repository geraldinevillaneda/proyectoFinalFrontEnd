<<<<<<< HEAD
'use strict';
=======
"use strict";
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f

Object.defineProperty(exports, "__esModule", {
  value: true
});
<<<<<<< HEAD

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var schema = [{
  enum: ['always'],
=======
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const schema = [{
  enum: ['always', 'never'],
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
  type: 'string'
}, {
  additionalProperties: false,
  properties: {
    annotateUndefined: {
      enum: ['always', 'never', 'ignore', 'always-enforce'],
      type: 'string'
    },
    excludeArrowFunctions: {
      enum: [false, true, 'expressionsOnly']
    },
    excludeMatching: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    includeOnlyMatching: {
      items: {
        type: 'string'
      },
      type: 'array'
    }
  },
  type: 'object'
}];

<<<<<<< HEAD
var create = function create(context) {
  var annotateReturn = (_lodash2.default.get(context, 'options[0]') || 'always') === 'always';
  var annotateUndefined = _lodash2.default.get(context, 'options[1].annotateUndefined') || 'never';
  var skipArrows = _lodash2.default.get(context, 'options[1].excludeArrowFunctions') || false;

  var makeRegExp = function makeRegExp(str) {
    return new RegExp(str);
  };

  var excludeMatching = _lodash2.default.get(context, 'options[1].excludeMatching', []).map(makeRegExp);
  var includeOnlyMatching = _lodash2.default.get(context, 'options[1].includeOnlyMatching', []).map(makeRegExp);

  var targetNodes = [];

  var registerFunction = function registerFunction(functionNode) {
=======
const makeRegExp = str => {
  return new RegExp(str);
};

const isUndefinedReturnType = returnNode => {
  return returnNode.argument === null || returnNode.argument.name === 'undefined' || returnNode.argument.operator === 'void';
};

const create = context => {
  const annotateReturn = (_lodash.default.get(context, 'options[0]') || 'always') === 'always';
  const annotateUndefined = _lodash.default.get(context, 'options[1].annotateUndefined') || 'never';
  const skipArrows = _lodash.default.get(context, 'options[1].excludeArrowFunctions') || false;

  const excludeMatching = _lodash.default.get(context, 'options[1].excludeMatching', []).map(makeRegExp);

  const includeOnlyMatching = _lodash.default.get(context, 'options[1].includeOnlyMatching', []).map(makeRegExp);

  const targetNodes = [];

  const registerFunction = functionNode => {
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    targetNodes.push({
      functionNode
    });
  };

<<<<<<< HEAD
  var isUndefinedReturnType = function isUndefinedReturnType(returnNode) {
    return returnNode.argument === null || returnNode.argument.name === 'undefined' || returnNode.argument.operator === 'void';
  };

  var getIsReturnTypeAnnotationUndefined = function getIsReturnTypeAnnotationUndefined(targetNode) {
    var isReturnTypeAnnotationLiteralUndefined = _lodash2.default.get(targetNode, 'functionNode.returnType.typeAnnotation.id.name') === 'undefined' && _lodash2.default.get(targetNode, 'functionNode.returnType.typeAnnotation.type') === 'GenericTypeAnnotation';
    var isReturnTypeAnnotationVoid = _lodash2.default.get(targetNode, 'functionNode.returnType.typeAnnotation.type') === 'VoidTypeAnnotation';
    var isAsyncReturnTypeAnnotationVoid = _lodash2.default.get(targetNode, 'functionNode.async') && _lodash2.default.get(targetNode, 'functionNode.returnType.typeAnnotation.id.name') === 'Promise' && (_lodash2.default.get(targetNode, 'functionNode.returnType.typeAnnotation.typeParameters.params[0].type') === 'VoidTypeAnnotation' || _lodash2.default.get(targetNode, 'functionNode.returnType.typeAnnotation.typeParameters.params[0].id.name') === 'undefined' && _lodash2.default.get(targetNode, 'functionNode.returnType.typeAnnotation.typeParameters.params[0].type') === 'GenericTypeAnnotation');

    return isReturnTypeAnnotationLiteralUndefined || isReturnTypeAnnotationVoid || isAsyncReturnTypeAnnotationVoid;
  };

  var shouldFilterNode = function shouldFilterNode(functionNode) {
    var isArrow = functionNode.type === 'ArrowFunctionExpression';
    var isMethod = functionNode.parent && functionNode.parent.type === 'MethodDefinition';
    var propertyNodes = ['Property', 'ClassProperty'];
    var isProperty = functionNode.parent && propertyNodes.includes(functionNode.parent.type);
    var selector = void 0;
=======
  const getIsReturnTypeAnnotationUndefined = targetNode => {
    const isReturnTypeAnnotationLiteralUndefined = _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.id.name') === 'undefined' && _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.type') === 'GenericTypeAnnotation';
    const isReturnTypeAnnotationVoid = _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.type') === 'VoidTypeAnnotation';
    const isAsyncReturnTypeAnnotationVoid = _lodash.default.get(targetNode, 'functionNode.async') && _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.id.name') === 'Promise' && (_lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.typeParameters.params[0].type') === 'VoidTypeAnnotation' || _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.typeParameters.params[0].id.name') === 'undefined' && _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.typeParameters.params[0].type') === 'GenericTypeAnnotation');
    return isReturnTypeAnnotationLiteralUndefined || isReturnTypeAnnotationVoid || isAsyncReturnTypeAnnotationVoid;
  };

  const shouldFilterNode = functionNode => {
    const isArrow = functionNode.type === 'ArrowFunctionExpression';
    const isMethod = functionNode.parent && functionNode.parent.type === 'MethodDefinition';
    const propertyNodes = ['Property', 'ClassProperty'];
    const isProperty = functionNode.parent && propertyNodes.includes(functionNode.parent.type);
    let selector;
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f

    if (isMethod || isProperty) {
      selector = 'parent.key.name';
    } else if (isArrow) {
      selector = 'parent.id.name';
    } else {
      selector = 'id.name';
    }
<<<<<<< HEAD
    var identifierName = _lodash2.default.get(functionNode, selector);

    var checkRegExp = function checkRegExp(regex) {
      return regex.test(identifierName);
    };

    if (excludeMatching.length && _lodash2.default.some(excludeMatching, checkRegExp)) {
      return true;
    }

    if (includeOnlyMatching.length && !_lodash2.default.some(includeOnlyMatching, checkRegExp)) {
=======

    const identifierName = _lodash.default.get(functionNode, selector);

    const checkRegExp = regex => {
      return regex.test(identifierName);
    };

    if (excludeMatching.length && _lodash.default.some(excludeMatching, checkRegExp)) {
      return true;
    }

    if (includeOnlyMatching.length && !_lodash.default.some(includeOnlyMatching, checkRegExp)) {
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
      return true;
    }

    return false;
<<<<<<< HEAD
  };

  // eslint-disable-next-line complexity
  var evaluateFunction = function evaluateFunction(functionNode) {
    var targetNode = targetNodes.pop();
=======
  }; // eslint-disable-next-line complexity


  const evaluateFunction = functionNode => {
    const targetNode = targetNodes.pop();
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f

    if (functionNode !== targetNode.functionNode) {
      throw new Error('Mismatch.');
    }

<<<<<<< HEAD
    var isArrow = functionNode.type === 'ArrowFunctionExpression';
    var isArrowFunctionExpression = functionNode.expression;
    var isFunctionReturnUndefined = !isArrowFunctionExpression && !functionNode.generator && (!targetNode.returnStatementNode || isUndefinedReturnType(targetNode.returnStatementNode));
    var isReturnTypeAnnotationUndefined = getIsReturnTypeAnnotationUndefined(targetNode);
=======
    const isArrow = functionNode.type === 'ArrowFunctionExpression';
    const isArrowFunctionExpression = functionNode.expression;
    const isFunctionReturnUndefined = !isArrowFunctionExpression && !functionNode.generator && (!targetNode.returnStatementNode || isUndefinedReturnType(targetNode.returnStatementNode));
    const isReturnTypeAnnotationUndefined = getIsReturnTypeAnnotationUndefined(targetNode);
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f

    if (skipArrows === 'expressionsOnly' && isArrowFunctionExpression || skipArrows === true && isArrow || shouldFilterNode(functionNode)) {
      return;
    }

<<<<<<< HEAD
    var returnType = functionNode.returnType || isArrow && _lodash2.default.get(functionNode, 'parent.id.typeAnnotation');
=======
    const returnType = functionNode.returnType || isArrow && _lodash.default.get(functionNode, 'parent.id.typeAnnotation');
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f

    if (isFunctionReturnUndefined && isReturnTypeAnnotationUndefined && annotateUndefined === 'never') {
      context.report(functionNode, 'Must not annotate undefined return type.');
    } else if (isFunctionReturnUndefined && !isReturnTypeAnnotationUndefined && annotateUndefined === 'always') {
      context.report(functionNode, 'Must annotate undefined return type.');
    } else if ((annotateUndefined === 'always-enforce' || !isFunctionReturnUndefined && !isReturnTypeAnnotationUndefined) && annotateReturn && !returnType && !shouldFilterNode(functionNode)) {
      context.report(functionNode, 'Missing return type annotation.');
    }
  };

<<<<<<< HEAD
  var evaluateNoise = function evaluateNoise() {
=======
  const evaluateNoise = () => {
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    targetNodes.pop();
  };

  return {
    ArrowFunctionExpression: registerFunction,
    'ArrowFunctionExpression:exit': evaluateFunction,
    ClassDeclaration: registerFunction,
    'ClassDeclaration:exit': evaluateNoise,
    ClassExpression: registerFunction,
    'ClassExpression:exit': evaluateNoise,
    FunctionDeclaration: registerFunction,
    'FunctionDeclaration:exit': evaluateFunction,
    FunctionExpression: registerFunction,
    'FunctionExpression:exit': evaluateFunction,
<<<<<<< HEAD
    ReturnStatement: function ReturnStatement(node) {
=======
    ReturnStatement: node => {
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
      if (targetNodes.length) {
        targetNodes[targetNodes.length - 1].returnStatementNode = node;
      }
    }
  };
};

<<<<<<< HEAD
exports.default = {
  create,
  schema
};
=======
var _default = {
  create,
  schema
};
exports.default = _default;
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
module.exports = exports.default;