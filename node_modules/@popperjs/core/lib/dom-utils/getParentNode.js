import getNodeName from "./getNodeName.js";
import getDocumentElement from "./getDocumentElement.js";
<<<<<<< HEAD
import { isShadowRoot } from "./instanceOf.js";
=======
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
export default function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
<<<<<<< HEAD
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
=======
    element.parentNode || // DOM Element detected
    // $FlowFixMe[incompatible-return]: need a better way to handle this...
    element.host || // ShadowRoot detected
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}