import getScrollParent from "./getScrollParent.js";
import getParentNode from "./getParentNode.js";
<<<<<<< HEAD
=======
import getNodeName from "./getNodeName.js";
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
import getWindow from "./getWindow.js";
import isScrollParent from "./isScrollParent.js";
/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

export default function listScrollParents(element, list) {
<<<<<<< HEAD
  var _element$ownerDocumen;

=======
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
<<<<<<< HEAD
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
=======
  var isBody = getNodeName(scrollParent) === 'body';
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}