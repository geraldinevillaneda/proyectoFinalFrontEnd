// @flow
import getNodeName from './getNodeName';
import getDocumentElement from './getDocumentElement';
<<<<<<< HEAD
import { isShadowRoot } from './instanceOf';
=======
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f

export default function getParentNode(element: Node | ShadowRoot): Node {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
<<<<<<< HEAD
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
=======
    // $FlowFixMe[incompatible-return]: need a better way to handle this...
    element.host || // ShadowRoot detected
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback
  );
}
