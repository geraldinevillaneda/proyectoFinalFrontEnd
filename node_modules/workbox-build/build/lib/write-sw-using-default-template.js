"use strict";

<<<<<<< HEAD
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

=======
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
const fse = require('fs-extra');

<<<<<<< HEAD
const path = require('path');
=======
const upath = require('upath');

const bundle = require('./bundle');
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f

const errors = require('./errors');

const populateSWTemplate = require('./populate-sw-template');

<<<<<<< HEAD
module.exports =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* ({
=======
module.exports = async ({
  babelPresetEnvTargets,
  cacheId,
  cleanupOutdatedCaches,
  clientsClaim,
  directoryIndex,
  disableDevLogs,
  ignoreURLParametersMatching,
  importScripts,
  inlineWorkboxRuntime,
  manifestEntries,
  mode,
  navigateFallback,
  navigateFallbackDenylist,
  navigateFallbackAllowlist,
  navigationPreload,
  offlineGoogleAnalytics,
  runtimeCaching,
  skipWaiting,
  sourcemap,
  swDest
}) => {
  const outputDir = upath.dirname(swDest);

  try {
    await fse.mkdirp(outputDir);
  } catch (error) {
    throw new Error(`${errors['unable-to-make-sw-directory']}. ` + `'${error.message}'`);
  }

  const unbundledCode = populateSWTemplate({
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    cacheId,
    cleanupOutdatedCaches,
    clientsClaim,
    directoryIndex,
<<<<<<< HEAD
    handleFetch,
    ignoreURLParametersMatching,
    importScripts,
    manifestEntries,
    modulePathPrefix,
    navigateFallback,
    navigateFallbackBlacklist,
    navigateFallbackWhitelist,
    navigationPreload,
    offlineGoogleAnalytics,
    runtimeCaching,
    skipWaiting,
    swDest,
    workboxSWImport
  }) {
    try {
      yield fse.mkdirp(path.dirname(swDest));
    } catch (error) {
      throw new Error(`${errors['unable-to-make-sw-directory']}. ` + `'${error.message}'`);
    }

    const populatedTemplate = populateSWTemplate({
      cacheId,
      cleanupOutdatedCaches,
      clientsClaim,
      directoryIndex,
      handleFetch,
      ignoreURLParametersMatching,
      importScripts,
      manifestEntries,
      modulePathPrefix,
      navigateFallback,
      navigateFallbackBlacklist,
      navigateFallbackWhitelist,
      navigationPreload,
      offlineGoogleAnalytics,
      runtimeCaching,
      skipWaiting,
      workboxSWImport
    });

    try {
      yield fse.writeFile(swDest, populatedTemplate);
    } catch (error) {
      if (error.code === 'EISDIR') {
        // See https://github.com/GoogleChrome/workbox/issues/612
        throw new Error(errors['sw-write-failure-directory']);
      }

      throw new Error(`${errors['sw-write-failure']}. '${error.message}'`);
    }
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();
=======
    disableDevLogs,
    ignoreURLParametersMatching,
    importScripts,
    manifestEntries,
    navigateFallback,
    navigateFallbackDenylist,
    navigateFallbackAllowlist,
    navigationPreload,
    offlineGoogleAnalytics,
    runtimeCaching,
    skipWaiting
  });

  try {
    const files = await bundle({
      babelPresetEnvTargets,
      inlineWorkboxRuntime,
      mode,
      sourcemap,
      swDest,
      unbundledCode
    });
    const filePaths = [];

    for (const file of files) {
      const filePath = upath.resolve(file.name);
      filePaths.push(filePath);
      await fse.writeFile(filePath, file.contents);
    }

    return filePaths;
  } catch (error) {
    if (error.code === 'EISDIR') {
      // See https://github.com/GoogleChrome/workbox/issues/612
      throw new Error(errors['sw-write-failure-directory']);
    }

    throw new Error(`${errors['sw-write-failure']} '${error.message}'`);
  }
};
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
