<<<<<<< HEAD
{"version":3,"file":"workbox-expiration.dev.js","sources":["../_version.mjs","../models/CacheTimestampsModel.mjs","../CacheExpiration.mjs","../Plugin.mjs","../index.mjs"],"sourcesContent":["try{self['workbox:expiration:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {DBWrapper} from 'workbox-core/_private/DBWrapper.mjs';\nimport {deleteDatabase} from 'workbox-core/_private/deleteDatabase.mjs';\nimport '../_version.mjs';\n\n\nconst DB_NAME = 'workbox-expiration';\nconst OBJECT_STORE_NAME = 'cache-entries';\n\nconst normalizeURL = (unNormalizedUrl) => {\n  const url = new URL(unNormalizedUrl, location);\n  url.hash = '';\n\n  return url.href;\n};\n\n\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n  /**\n   *\n   * @param {string} cacheName\n   *\n   * @private\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheName;\n\n    this._db = new DBWrapper(DB_NAME, 1, {\n      onupgradeneeded: (event) => this._handleUpgrade(event),\n    });\n  }\n\n  /**\n   * Should perform an upgrade of indexedDB.\n   *\n   * @param {Event} event\n   *\n   * @private\n   */\n  _handleUpgrade(event) {\n    const db = event.target.result;\n\n    // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n    // have to use the `id` keyPath here and create our own values (a\n    // concatenation of `url + cacheName`) instead of simply using\n    // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n    const objStore = db.createObjectStore(OBJECT_STORE_NAME, {keyPath: 'id'});\n\n    // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n    // create a single index with the keyPath `['cacheName', 'timestamp']`\n    // instead of doing both these indexes.\n    objStore.createIndex('cacheName', 'cacheName', {unique: false});\n    objStore.createIndex('timestamp', 'timestamp', {unique: false});\n\n    // Previous versions of `workbox-expiration` used `this._cacheName`\n    // as the IDBDatabase name.\n    deleteDatabase(this._cacheName);\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} timestamp\n   *\n   * @private\n   */\n  async setTimestamp(url, timestamp) {\n    url = normalizeURL(url);\n\n    await this._db.put(OBJECT_STORE_NAME, {\n      url,\n      timestamp,\n      cacheName: this._cacheName,\n      // Creating an ID from the URL and cache name won't be necessary once\n      // Edge switches to Chromium and all browsers we support work with\n      // array keyPaths.\n      id: this._getId(url),\n    });\n  }\n\n  /**\n   * Returns the timestamp stored for a given URL.\n   *\n   * @param {string} url\n   * @return {number}\n   *\n   * @private\n   */\n  async getTimestamp(url) {\n    const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n    return entry.timestamp;\n  }\n\n  /**\n   * Iterates through all the entries in the object store (from newest to\n   * oldest) and removes entries once either `maxCount` is reached or the\n   * entry's timestamp is less than `minTimestamp`.\n   *\n   * @param {number} minTimestamp\n   * @param {number} maxCount\n   *\n   * @private\n   */\n  async expireEntries(minTimestamp, maxCount) {\n    const entriesToDelete = await this._db.transaction(\n        OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n          const store = txn.objectStore(OBJECT_STORE_NAME);\n          const entriesToDelete = [];\n          let entriesNotDeletedCount = 0;\n\n          store.index('timestamp')\n              .openCursor(null, 'prev')\n              .onsuccess = ({target}) => {\n                const cursor = target.result;\n                if (cursor) {\n                  const result = cursor.value;\n                  // TODO(philipwalton): once we can use a multi-key index, we\n                  // won't have to check `cacheName` here.\n                  if (result.cacheName === this._cacheName) {\n                    // Delete an entry if it's older than the max age or\n                    // if we already have the max number allowed.\n                    if ((minTimestamp && result.timestamp < minTimestamp) ||\n                        (maxCount && entriesNotDeletedCount >= maxCount)) {\n                      // TODO(philipwalton): we should be able to delete the\n                      // entry right here, but doing so causes an iteration\n                      // bug in Safari stable (fixed in TP). Instead we can\n                      // store the keys of the entries to delete, and then\n                      // delete the separate transactions.\n                      // https://github.com/GoogleChrome/workbox/issues/1978\n                      // cursor.delete();\n\n                      // We only need to return the URL, not the whole entry.\n                      entriesToDelete.push(cursor.value);\n                    } else {\n                      entriesNotDeletedCount++;\n                    }\n                  }\n                  cursor.continue();\n                } else {\n                  done(entriesToDelete);\n                }\n              };\n        });\n\n    // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n    // we should be able to remove this loop and do the entry deletion in the\n    // cursor loop above:\n    // https://github.com/GoogleChrome/workbox/issues/1978\n    const urlsDeleted = [];\n    for (const entry of entriesToDelete) {\n      await this._db.delete(OBJECT_STORE_NAME, entry.id);\n      urlsDeleted.push(entry.url);\n    }\n\n    return urlsDeleted;\n  }\n\n  /**\n   * Takes a URL and returns an ID that will be unique in the object store.\n   *\n   * @param {string} url\n   * @return {string}\n   *\n   * @private\n   */\n  _getId(url) {\n    // Creating an ID from the URL and cache name won't be necessary once\n    // Edge switches to Chromium and all browsers we support work with\n    // array keyPaths.\n    return this._cacheName + '|' + normalizeURL(url);\n  }\n}\n\nexport {CacheTimestampsModel};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {CacheTimestampsModel} from './models/CacheTimestampsModel.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport './_version.mjs';\n\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox.expiration\n */\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   */\n  constructor(cacheName, config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName',\n      });\n\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n\n        // TODO: Assert is positive\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n\n        // TODO: Assert is positive\n      }\n    }\n\n    this._isRunning = false;\n    this._rerunRequested = false;\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n    this._isRunning = true;\n\n    const minTimestamp = this._maxAgeSeconds ?\n        Date.now() - (this._maxAgeSeconds * 1000) : undefined;\n\n    const urlsExpired = await this._timestampModel.expireEntries(\n        minTimestamp, this._maxEntries);\n\n    // Delete URLs from the cache\n    const cache = await caches.open(this._cacheName);\n    for (const url of urlsExpired) {\n      await cache.delete(url);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(\n            `Expired ${urlsExpired.length} ` +\n          `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n          `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n          `'${this._cacheName}' cache.`);\n        logger.log(`Expired the following ${urlsExpired.length === 1 ?\n            'URL' : 'URLs'}:`);\n        urlsExpired.forEach((url) => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n\n    this._isRunning = false;\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      this.expireEntries();\n    }\n  }\n\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url',\n      });\n    }\n\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n  async isURLExpired(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this._maxAgeSeconds) {\n        throw new WorkboxError(`expired-test-without-max-age`, {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds',\n        });\n      }\n    }\n\n    const timestamp = await this._timestampModel.getTimestamp(url);\n    const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\n    return (timestamp < expireOlderThan);\n  }\n\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n}\n\nexport {CacheExpiration};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {registerQuotaErrorCallback}\n  from 'workbox-core/registerQuotaErrorCallback.mjs';\n\nimport {CacheExpiration} from './CacheExpiration.mjs';\nimport './_version.mjs';\n\n/**\n * This plugin can be used in the Workbox APIs to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed from the cache first.\n *\n * @memberof workbox.expiration\n */\nclass Plugin {\n  /**\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n   * automatic deletion if the available storage quota has been exceeded.\n   */\n  constructor(config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n      }\n    }\n\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n\n    if (config.purgeOnQuotaError) {\n      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n    }\n  }\n\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n  _getCacheExpiration(cacheName) {\n    if (cacheName === cacheNames.getRuntimeName()) {\n      throw new WorkboxError('expire-custom-caches-only');\n    }\n\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\n    if (!cacheExpiration) {\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\n      this._cacheExpirations.set(cacheName, cacheExpiration);\n    }\n    return cacheExpiration;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when a `Response` is about to be returned\n   * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n   * the handler. It allows the `Response` to be inspected for freshness and\n   * prevents it from being used if the `Response`'s `Date` header value is\n   * older than the configured `maxAgeSeconds`.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache the response is in.\n   * @param {Response} options.cachedResponse The `Response` object that's been\n   *     read from a cache and whose freshness should be checked.\n   * @return {Response} Either the `cachedResponse`, if it's\n   *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n   *\n   * @private\n   */\n  cachedResponseWillBeUsed({event, request, cacheName, cachedResponse}) {\n    if (!cachedResponse) {\n      return null;\n    }\n\n    let isFresh = this._isResponseDateFresh(cachedResponse);\n\n    // Expire entries to ensure that even if the expiration date has\n    // expired, it'll only be used once.\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    cacheExpiration.expireEntries();\n\n    // Update the metadata for the request URL to the current timestamp,\n    // but don't `await` it as we don't want to block the response.\n    const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n    if (event) {\n      try {\n        event.waitUntil(updateTimestampDone);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache entry for '${getFriendlyURL(event.request.url)}'.`);\n        }\n      }\n    }\n\n    return isFresh ? cachedResponse : null;\n  }\n\n  /**\n   * @param {Response} cachedResponse\n   * @return {boolean}\n   *\n   * @private\n   */\n  _isResponseDateFresh(cachedResponse) {\n    if (!this._maxAgeSeconds) {\n      // We aren't expiring by age, so return true, it's fresh\n      return true;\n    }\n\n    // Check if the 'date' header will suffice a quick expiration check.\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n    // discussion.\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n    if (dateHeaderTimestamp === null) {\n      // Unable to parse date, so assume it's fresh.\n      return true;\n    }\n\n    // If we have a valid headerTime, then our response is fresh iff the\n    // headerTime plus maxAgeSeconds is greater than the current time.\n    const now = Date.now();\n    return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\n  }\n\n  /**\n   * This method will extract the data header and parse it into a useful\n   * value.\n   *\n   * @param {Response} cachedResponse\n   * @return {number}\n   *\n   * @private\n   */\n  _getDateHeaderTimestamp(cachedResponse) {\n    if (!cachedResponse.headers.has('date')) {\n      return null;\n    }\n\n    const dateHeader = cachedResponse.headers.get('date');\n    const parsedDate = new Date(dateHeader);\n    const headerTime = parsedDate.getTime();\n\n    // If the Date header was invalid for some reason, parsedDate.getTime()\n    // will return NaN.\n    if (isNaN(headerTime)) {\n      return null;\n    }\n\n    return headerTime;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when an entry is added to a cache.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache that was updated.\n   * @param {string} options.request The Request for the cached entry.\n   *\n   * @private\n   */\n  async cacheDidUpdate({cacheName, request}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'cacheName',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'request',\n      });\n    }\n\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    await cacheExpiration.updateTimestamp(request.url);\n    await cacheExpiration.expireEntries();\n  }\n\n\n  /**\n   * This is a helper method that performs two operations:\n   *\n   * - Deletes *all* the underlying Cache instances associated with this plugin\n   * instance, by calling caches.delete() on your behalf.\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\n   * details for each Cache instance.\n   *\n   * When using cache expiration, calling this method is preferable to calling\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\n   *\n   * Note that if you're *not* using cache expiration for a given cache, calling\n   * `caches.delete()` and passing in the cache's name should be sufficient.\n   * There is no Workbox-specific method needed for cleanup in that case.\n   */\n  async deleteCacheAndMetadata() {\n    // Do this one at a time instead of all at once via `Promise.all()` to\n    // reduce the chance of inconsistency if a promise rejects.\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n      await caches.delete(cacheName);\n      await cacheExpiration.delete();\n    }\n\n    // Reset this._cacheExpirations to its initial state.\n    this._cacheExpirations = new Map();\n  }\n}\n\nexport {Plugin};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {CacheExpiration} from './CacheExpiration.mjs';\nimport {Plugin} from './Plugin.mjs';\nimport './_version.mjs';\n\n\n/**\n * @namespace workbox.expiration\n */\n\nexport {\n  CacheExpiration,\n  Plugin,\n};\n"],"names":["self","_","e","DB_NAME","OBJECT_STORE_NAME","normalizeURL","unNormalizedUrl","url","URL","location","hash","href","CacheTimestampsModel","constructor","cacheName","_cacheName","_db","DBWrapper","onupgradeneeded","event","_handleUpgrade","db","target","result","objStore","createObjectStore","keyPath","createIndex","unique","deleteDatabase","setTimestamp","timestamp","put","id","_getId","getTimestamp","entry","get","expireEntries","minTimestamp","maxCount","entriesToDelete","transaction","txn","done","store","objectStore","entriesNotDeletedCount","index","openCursor","onsuccess","cursor","value","push","continue","urlsDeleted","delete","CacheExpiration","config","assert","isType","moduleName","className","funcName","paramName","maxEntries","maxAgeSeconds","WorkboxError","_isRunning","_rerunRequested","_maxEntries","_maxAgeSeconds","_timestampModel","Date","now","undefined","urlsExpired","cache","caches","open","length","logger","groupCollapsed","log","forEach","groupEnd","debug","updateTimestamp","isURLExpired","methodName","expireOlderThan","Infinity","Plugin","_config","_cacheExpirations","Map","purgeOnQuotaError","registerQuotaErrorCallback","deleteCacheAndMetadata","_getCacheExpiration","cacheNames","getRuntimeName","cacheExpiration","set","cachedResponseWillBeUsed","request","cachedResponse","isFresh","_isResponseDateFresh","updateTimestampDone","waitUntil","error","warn","getFriendlyURL","dateHeaderTimestamp","_getDateHeaderTimestamp","headers","has","dateHeader","parsedDate","headerTime","getTime","isNaN","cacheDidUpdate","isInstance","Request"],"mappings":"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"}
=======
{"version":3,"file":"workbox-expiration.dev.js","sources":["../_version.js","../models/CacheTimestampsModel.js","../CacheExpiration.js","../ExpirationPlugin.js"],"sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:expiration:5.1.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { DBWrapper } from 'workbox-core/_private/DBWrapper.js';\nimport { deleteDatabase } from 'workbox-core/_private/deleteDatabase.js';\nimport '../_version.js';\nconst DB_NAME = 'workbox-expiration';\nconst OBJECT_STORE_NAME = 'cache-entries';\nconst normalizeURL = (unNormalizedUrl) => {\n    const url = new URL(unNormalizedUrl, location.href);\n    url.hash = '';\n    return url.href;\n};\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n    /**\n     *\n     * @param {string} cacheName\n     *\n     * @private\n     */\n    constructor(cacheName) {\n        this._cacheName = cacheName;\n        this._db = new DBWrapper(DB_NAME, 1, {\n            onupgradeneeded: (event) => this._handleUpgrade(event),\n        });\n    }\n    /**\n     * Should perform an upgrade of indexedDB.\n     *\n     * @param {Event} event\n     *\n     * @private\n     */\n    _handleUpgrade(event) {\n        const db = event.target.result;\n        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n        // have to use the `id` keyPath here and create our own values (a\n        // concatenation of `url + cacheName`) instead of simply using\n        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n        const objStore = db.createObjectStore(OBJECT_STORE_NAME, { keyPath: 'id' });\n        // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n        // create a single index with the keyPath `['cacheName', 'timestamp']`\n        // instead of doing both these indexes.\n        objStore.createIndex('cacheName', 'cacheName', { unique: false });\n        objStore.createIndex('timestamp', 'timestamp', { unique: false });\n        // Previous versions of `workbox-expiration` used `this._cacheName`\n        // as the IDBDatabase name.\n        deleteDatabase(this._cacheName);\n    }\n    /**\n     * @param {string} url\n     * @param {number} timestamp\n     *\n     * @private\n     */\n    async setTimestamp(url, timestamp) {\n        url = normalizeURL(url);\n        const entry = {\n            url,\n            timestamp,\n            cacheName: this._cacheName,\n            // Creating an ID from the URL and cache name won't be necessary once\n            // Edge switches to Chromium and all browsers we support work with\n            // array keyPaths.\n            id: this._getId(url),\n        };\n        await this._db.put(OBJECT_STORE_NAME, entry);\n    }\n    /**\n     * Returns the timestamp stored for a given URL.\n     *\n     * @param {string} url\n     * @return {number}\n     *\n     * @private\n     */\n    async getTimestamp(url) {\n        const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n        return entry.timestamp;\n    }\n    /**\n     * Iterates through all the entries in the object store (from newest to\n     * oldest) and removes entries once either `maxCount` is reached or the\n     * entry's timestamp is less than `minTimestamp`.\n     *\n     * @param {number} minTimestamp\n     * @param {number} maxCount\n     * @return {Array<string>}\n     *\n     * @private\n     */\n    async expireEntries(minTimestamp, maxCount) {\n        const entriesToDelete = await this._db.transaction(OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n            const store = txn.objectStore(OBJECT_STORE_NAME);\n            const request = store.index('timestamp').openCursor(null, 'prev');\n            const entriesToDelete = [];\n            let entriesNotDeletedCount = 0;\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (cursor) {\n                    const result = cursor.value;\n                    // TODO(philipwalton): once we can use a multi-key index, we\n                    // won't have to check `cacheName` here.\n                    if (result.cacheName === this._cacheName) {\n                        // Delete an entry if it's older than the max age or\n                        // if we already have the max number allowed.\n                        if ((minTimestamp && result.timestamp < minTimestamp) ||\n                            (maxCount && entriesNotDeletedCount >= maxCount)) {\n                            // TODO(philipwalton): we should be able to delete the\n                            // entry right here, but doing so causes an iteration\n                            // bug in Safari stable (fixed in TP). Instead we can\n                            // store the keys of the entries to delete, and then\n                            // delete the separate transactions.\n                            // https://github.com/GoogleChrome/workbox/issues/1978\n                            // cursor.delete();\n                            // We only need to return the URL, not the whole entry.\n                            entriesToDelete.push(cursor.value);\n                        }\n                        else {\n                            entriesNotDeletedCount++;\n                        }\n                    }\n                    cursor.continue();\n                }\n                else {\n                    done(entriesToDelete);\n                }\n            };\n        });\n        // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n        // we should be able to remove this loop and do the entry deletion in the\n        // cursor loop above:\n        // https://github.com/GoogleChrome/workbox/issues/1978\n        const urlsDeleted = [];\n        for (const entry of entriesToDelete) {\n            await this._db.delete(OBJECT_STORE_NAME, entry.id);\n            urlsDeleted.push(entry.url);\n        }\n        return urlsDeleted;\n    }\n    /**\n     * Takes a URL and returns an ID that will be unique in the object store.\n     *\n     * @param {string} url\n     * @return {string}\n     *\n     * @private\n     */\n    _getId(url) {\n        // Creating an ID from the URL and cache name won't be necessary once\n        // Edge switches to Chromium and all browsers we support work with\n        // array keyPaths.\n        return this._cacheName + '|' + normalizeURL(url);\n    }\n}\nexport { CacheTimestampsModel };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof module:workbox-expiration\n */\nclass CacheExpiration {\n    /**\n     * To construct a new CacheExpiration instance you must provide at least\n     * one of the `config` properties.\n     *\n     * @param {string} cacheName Name of the cache to apply restrictions to.\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     */\n    constructor(cacheName, config = {}) {\n        this._isRunning = false;\n        this._rerunRequested = false;\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(cacheName, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'constructor',\n                paramName: 'cacheName',\n            });\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n                // TODO: Assert is positive\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n                // TODO: Assert is positive\n            }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    /**\n     * Expires entries for the given cache and given criteria.\n     */\n    async expireEntries() {\n        if (this._isRunning) {\n            this._rerunRequested = true;\n            return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds ?\n            Date.now() - (this._maxAgeSeconds * 1000) : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        // Delete URLs from the cache\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired) {\n            await cache.delete(url);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (urlsExpired.length > 0) {\n                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +\n                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n                    `'${this._cacheName}' cache.`);\n                logger.log(`Expired the following ${urlsExpired.length === 1 ?\n                    'URL' : 'URLs'}:`);\n                urlsExpired.forEach((url) => logger.log(`    ${url}`));\n                logger.groupEnd();\n            }\n            else {\n                logger.debug(`Cache expiration ran and found no entries to remove.`);\n            }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n            this._rerunRequested = false;\n            dontWaitFor(this.expireEntries());\n        }\n    }\n    /**\n     * Update the timestamp for the given URL. This ensures the when\n     * removing entries based on maximum entries, most recently used\n     * is accurate or when expiring, the timestamp is up-to-date.\n     *\n     * @param {string} url\n     */\n    async updateTimestamp(url) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(url, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'updateTimestamp',\n                paramName: 'url',\n            });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    /**\n     * Can be used to check if a URL has expired or not before it's used.\n     *\n     * This requires a look up from IndexedDB, so can be slow.\n     *\n     * Note: This method will not remove the cached entry, call\n     * `expireEntries()` to remove indexedDB and Cache entries.\n     *\n     * @param {string} url\n     * @return {boolean}\n     */\n    async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n            if (process.env.NODE_ENV !== 'production') {\n                throw new WorkboxError(`expired-test-without-max-age`, {\n                    methodName: 'isURLExpired',\n                    paramName: 'maxAgeSeconds',\n                });\n            }\n            return false;\n        }\n        else {\n            const timestamp = await this._timestampModel.getTimestamp(url);\n            const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\n            return (timestamp < expireOlderThan);\n        }\n    }\n    /**\n     * Removes the IndexedDB object store used to keep track of cache expiration\n     * metadata.\n     */\n    async delete() {\n        // Make sure we don't attempt another rerun if we're called in the middle of\n        // a cache expiration.\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\n    }\n}\nexport { CacheExpiration };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheExpiration } from './CacheExpiration.js';\nimport './_version.js';\n/**\n * This plugin can be used in the Workbox APIs to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed\n * from the cache first.\n *\n * @memberof module:workbox-expiration\n */\nclass ExpirationPlugin {\n    /**\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n     * automatic deletion if the available storage quota has been exceeded.\n     */\n    constructor(config = {}) {\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when a `Response` is about to be returned\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n         * the handler. It allows the `Response` to be inspected for freshness and\n         * prevents it from being used if the `Response`'s `Date` header value is\n         * older than the configured `maxAgeSeconds`.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache the response is in.\n         * @param {Response} options.cachedResponse The `Response` object that's been\n         *     read from a cache and whose freshness should be checked.\n         * @return {Response} Either the `cachedResponse`, if it's\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse }) => {\n            if (!cachedResponse) {\n                return null;\n            }\n            const isFresh = this._isResponseDateFresh(cachedResponse);\n            // Expire entries to ensure that even if the expiration date has\n            // expired, it'll only be used once.\n            const cacheExpiration = this._getCacheExpiration(cacheName);\n            dontWaitFor(cacheExpiration.expireEntries());\n            // Update the metadata for the request URL to the current timestamp,\n            // but don't `await` it as we don't want to block the response.\n            const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n            if (event) {\n                try {\n                    event.waitUntil(updateTimestampDone);\n                }\n                catch (error) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // The event may not be a fetch event; only log the URL if it is.\n                        if ('request' in event) {\n                            logger.warn(`Unable to ensure service worker stays alive when ` +\n                                `updating cache entry for ` +\n                                `'${getFriendlyURL(event.request.url)}'.`);\n                        }\n                    }\n                }\n            }\n            return isFresh ? cachedResponse : null;\n        };\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when an entry is added to a cache.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache that was updated.\n         * @param {string} options.request The Request for the cached entry.\n         *\n         * @private\n         */\n        this.cacheDidUpdate = async ({ cacheName, request }) => {\n            if (process.env.NODE_ENV !== 'production') {\n                assert.isType(cacheName, 'string', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'cacheName',\n                });\n                assert.isInstance(request, Request, {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'request',\n                });\n            }\n            const cacheExpiration = this._getCacheExpiration(cacheName);\n            await cacheExpiration.updateTimestamp(request.url);\n            await cacheExpiration.expireEntries();\n        };\n        if (process.env.NODE_ENV !== 'production') {\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n            }\n        }\n        this._config = config;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheExpirations = new Map();\n        if (config.purgeOnQuotaError) {\n            registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n        }\n    }\n    /**\n     * A simple helper method to return a CacheExpiration instance for a given\n     * cache name.\n     *\n     * @param {string} cacheName\n     * @return {CacheExpiration}\n     *\n     * @private\n     */\n    _getCacheExpiration(cacheName) {\n        if (cacheName === cacheNames.getRuntimeName()) {\n            throw new WorkboxError('expire-custom-caches-only');\n        }\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\n        if (!cacheExpiration) {\n            cacheExpiration = new CacheExpiration(cacheName, this._config);\n            this._cacheExpirations.set(cacheName, cacheExpiration);\n        }\n        return cacheExpiration;\n    }\n    /**\n     * @param {Response} cachedResponse\n     * @return {boolean}\n     *\n     * @private\n     */\n    _isResponseDateFresh(cachedResponse) {\n        if (!this._maxAgeSeconds) {\n            // We aren't expiring by age, so return true, it's fresh\n            return true;\n        }\n        // Check if the 'date' header will suffice a quick expiration check.\n        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n        // discussion.\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n        if (dateHeaderTimestamp === null) {\n            // Unable to parse date, so assume it's fresh.\n            return true;\n        }\n        // If we have a valid headerTime, then our response is fresh iff the\n        // headerTime plus maxAgeSeconds is greater than the current time.\n        const now = Date.now();\n        return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\n    }\n    /**\n     * This method will extract the data header and parse it into a useful\n     * value.\n     *\n     * @param {Response} cachedResponse\n     * @return {number|null}\n     *\n     * @private\n     */\n    _getDateHeaderTimestamp(cachedResponse) {\n        if (!cachedResponse.headers.has('date')) {\n            return null;\n        }\n        const dateHeader = cachedResponse.headers.get('date');\n        const parsedDate = new Date(dateHeader);\n        const headerTime = parsedDate.getTime();\n        // If the Date header was invalid for some reason, parsedDate.getTime()\n        // will return NaN.\n        if (isNaN(headerTime)) {\n            return null;\n        }\n        return headerTime;\n    }\n    /**\n     * This is a helper method that performs two operations:\n     *\n     * - Deletes *all* the underlying Cache instances associated with this plugin\n     * instance, by calling caches.delete() on your behalf.\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\n     * details for each Cache instance.\n     *\n     * When using cache expiration, calling this method is preferable to calling\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\n     *\n     * Note that if you're *not* using cache expiration for a given cache, calling\n     * `caches.delete()` and passing in the cache's name should be sufficient.\n     * There is no Workbox-specific method needed for cleanup in that case.\n     */\n    async deleteCacheAndMetadata() {\n        // Do this one at a time instead of all at once via `Promise.all()` to\n        // reduce the chance of inconsistency if a promise rejects.\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n            await self.caches.delete(cacheName);\n            await cacheExpiration.delete();\n        }\n        // Reset this._cacheExpirations to its initial state.\n        this._cacheExpirations = new Map();\n    }\n}\nexport { ExpirationPlugin };\n"],"names":["self","_","e","DB_NAME","OBJECT_STORE_NAME","normalizeURL","unNormalizedUrl","url","URL","location","href","hash","CacheTimestampsModel","constructor","cacheName","_cacheName","_db","DBWrapper","onupgradeneeded","event","_handleUpgrade","db","target","result","objStore","createObjectStore","keyPath","createIndex","unique","deleteDatabase","setTimestamp","timestamp","entry","id","_getId","put","getTimestamp","get","expireEntries","minTimestamp","maxCount","entriesToDelete","transaction","txn","done","store","objectStore","request","index","openCursor","entriesNotDeletedCount","onsuccess","cursor","value","push","continue","urlsDeleted","delete","CacheExpiration","config","_isRunning","_rerunRequested","assert","isType","moduleName","className","funcName","paramName","maxEntries","maxAgeSeconds","WorkboxError","_maxEntries","_maxAgeSeconds","_timestampModel","Date","now","urlsExpired","cache","caches","open","length","logger","groupCollapsed","log","forEach","groupEnd","debug","dontWaitFor","updateTimestamp","isURLExpired","methodName","expireOlderThan","Infinity","ExpirationPlugin","cachedResponseWillBeUsed","cachedResponse","isFresh","_isResponseDateFresh","cacheExpiration","_getCacheExpiration","updateTimestampDone","waitUntil","error","warn","getFriendlyURL","cacheDidUpdate","isInstance","Request","_config","_cacheExpirations","Map","purgeOnQuotaError","registerQuotaErrorCallback","deleteCacheAndMetadata","cacheNames","getRuntimeName","set","dateHeaderTimestamp","_getDateHeaderTimestamp","headers","has","dateHeader","parsedDate","headerTime","getTime","isNaN"],"mappings":"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"}
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
