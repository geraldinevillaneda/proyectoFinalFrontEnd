"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = readInitialCoverage;

<<<<<<< HEAD
var _parser = require("@babel/parser");

var _traverse = _interopRequireDefault(require("@babel/traverse"));

var t = _interopRequireWildcard(require("@babel/types"));

var _constants = require("./constants");

var _instrumenter = require("./instrumenter");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function readInitialCoverage(code) {
=======
var _core = require("@babel/core");

var _schema = require("@istanbuljs/schema");

var _constants = require("./constants");

function getAst(code) {
  if (typeof code === 'object' && typeof code.type === 'string') {
    // Assume code is already a babel ast.
    return code;
  }

>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
  if (typeof code !== 'string') {
    throw new Error('Code must be a string');
  } // Parse as leniently as possible


<<<<<<< HEAD
  const ast = (0, _parser.parse)(code, {
    allowImportExportEverywhere: true,
    allowReturnOutsideFunction: true,
    allowSuperOutsideMethod: true,
    sourceType: 'script',
    plugins: (0, _instrumenter.defaultOpts)().plugins
  });
  let covScope;
  (0, _traverse.default)(ast, {
    ObjectProperty(path) {
      const node = path.node;

      if (!node.computed && t.isIdentifier(node.key) && node.key.name === _constants.MAGIC_KEY) {
=======
  return (0, _core.parseSync)(code, {
    babelrc: false,
    configFile: false,
    parserOpts: {
      allowImportExportEverywhere: true,
      allowReturnOutsideFunction: true,
      allowSuperOutsideMethod: true,
      sourceType: 'script',
      plugins: _schema.defaults.instrumenter.parserPlugins
    }
  });
}

function readInitialCoverage(code) {
  const ast = getAst(code);
  let covScope;
  (0, _core.traverse)(ast, {
    ObjectProperty(path) {
      const {
        node
      } = path;

      if (!node.computed && path.get('key').isIdentifier() && node.key.name === _constants.MAGIC_KEY) {
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
        const magicValue = path.get('value').evaluate();

        if (!magicValue.confident || magicValue.value !== _constants.MAGIC_VALUE) {
          return;
        }

        covScope = path.scope.getFunctionParent() || path.scope.getProgramParent();
        path.stop();
      }
    }

  });

  if (!covScope) {
    return null;
  }

  const result = {};

<<<<<<< HEAD
  for (var _i = 0, _arr = ['path', 'hash', 'gcv', 'coverageData']; _i < _arr.length; _i++) {
    const key = _arr[_i];
=======
  for (const key of ['path', 'hash', 'gcv', 'coverageData']) {
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    const binding = covScope.getOwnBinding(key);

    if (!binding) {
      return null;
    }

    const valuePath = binding.path.get('init');
    const value = valuePath.evaluate();

    if (!value.confident) {
      return null;
    }

    result[key] = value.value;
  }

  delete result.coverageData[_constants.MAGIC_KEY];
<<<<<<< HEAD
=======
  delete result.coverageData.hash;
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
  return result;
}