/**
 * @fileoverview Enforce curly braces or disallow unnecessary curly brace in JSX
 * @author Jacky Ho
 * @author Simon Lydell
 */

'use strict';

const arrayIncludes = require('array-includes');

const docsUrl = require('../util/docsUrl');
const jsxUtil = require('../util/jsx');

// ------------------------------------------------------------------------------
// Constants
// ------------------------------------------------------------------------------

const OPTION_ALWAYS = 'always';
const OPTION_NEVER = 'never';
const OPTION_IGNORE = 'ignore';

const OPTION_VALUES = [
  OPTION_ALWAYS,
  OPTION_NEVER,
  OPTION_IGNORE
];
const DEFAULT_CONFIG = {props: OPTION_NEVER, children: OPTION_NEVER};

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = {
  meta: {
    docs: {
      description:
<<<<<<< HEAD
        'Disallow unnecessary JSX expressions when literals alone are sufficient ' +
          'or enfore JSX expressions on literals in JSX children or attributes',
=======
        'Disallow unnecessary JSX expressions when literals alone are sufficient '
          + 'or enfore JSX expressions on literals in JSX children or attributes',
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-curly-brace-presence')
    },
    fixable: 'code',

<<<<<<< HEAD
=======
    messages: {
      unnecessaryCurly: 'Curly braces are unnecessary here.',
      missingCurly: 'Need to wrap this literal in a JSX expression.'
    },

>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    schema: [
      {
        oneOf: [
          {
            type: 'object',
            properties: {
              props: {enum: OPTION_VALUES},
              children: {enum: OPTION_VALUES}
            },
            additionalProperties: false
          },
          {
            enum: OPTION_VALUES
          }
        ]
      }
    ]
  },

  create(context) {
    const HTML_ENTITY_REGEX = () => /&[A-Za-z\d#]+;/g;
    const ruleOptions = context.options[0];
<<<<<<< HEAD
    const userConfig = typeof ruleOptions === 'string' ?
      {props: ruleOptions, children: ruleOptions} :
      Object.assign({}, DEFAULT_CONFIG, ruleOptions);
=======
    const userConfig = typeof ruleOptions === 'string'
      ? {props: ruleOptions, children: ruleOptions}
      : Object.assign({}, DEFAULT_CONFIG, ruleOptions);
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f

    function containsLineTerminators(rawStringValue) {
      return /[\n\r\u2028\u2029]/.test(rawStringValue);
    }

    function containsBackslash(rawStringValue) {
      return arrayIncludes(rawStringValue, '\\');
    }

    function containsHTMLEntity(rawStringValue) {
      return HTML_ENTITY_REGEX().test(rawStringValue);
    }

    function containsOnlyHtmlEntities(rawStringValue) {
      return rawStringValue.replace(HTML_ENTITY_REGEX(), '').trim() === '';
    }

    function containsDisallowedJSXTextChars(rawStringValue) {
      return /[{<>}]/.test(rawStringValue);
    }

    function containsQuoteCharacters(value) {
      return /['"]/.test(value);
    }

<<<<<<< HEAD
=======
    function containsMultilineComment(value) {
      return /\/\*/.test(value);
    }

>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    function escapeDoubleQuotes(rawStringValue) {
      return rawStringValue.replace(/\\"/g, '"').replace(/"/g, '\\"');
    }

    function escapeBackslashes(rawStringValue) {
      return rawStringValue.replace(/\\/g, '\\\\');
    }

<<<<<<< HEAD
    function needToEscapeCharacterForJSX(raw) {
      return (
        containsBackslash(raw) ||
        containsHTMLEntity(raw) ||
        containsDisallowedJSXTextChars(raw)
=======
    function needToEscapeCharacterForJSX(raw, node) {
      return (
        containsBackslash(raw)
        || containsHTMLEntity(raw)
        || (node.parent.type !== 'JSXAttribute' && containsDisallowedJSXTextChars(raw))
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
      );
    }

    function containsWhitespaceExpression(child) {
      if (child.type === 'JSXExpressionContainer') {
        const value = child.expression.value;
        return value ? jsxUtil.isWhiteSpaces(value) : false;
      }
      return false;
    }

    function isLineBreak(text) {
      return containsLineTerminators(text) && text.trim() === '';
    }

    function wrapNonHTMLEntities(text) {
      const HTML_ENTITY = '<HTML_ENTITY>';
<<<<<<< HEAD
      const withCurlyBraces = text.split(HTML_ENTITY_REGEX()).map(word => (
=======
      const withCurlyBraces = text.split(HTML_ENTITY_REGEX()).map((word) => (
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
        word === '' ? '' : `{${JSON.stringify(word)}}`
      )).join(HTML_ENTITY);

      const htmlEntities = text.match(HTML_ENTITY_REGEX());
      return htmlEntities.reduce((acc, htmlEntitiy) => (
        acc.replace(HTML_ENTITY, htmlEntitiy)
      ), withCurlyBraces);
    }

    function wrapWithCurlyBraces(rawText) {
      if (!containsLineTerminators(rawText)) {
        return `{${JSON.stringify(rawText)}}`;
      }

      return rawText.split('\n').map((line) => {
        if (line.trim() === '') {
          return line;
        }
        const firstCharIndex = line.search(/[^\s]/);
        const leftWhitespace = line.slice(0, firstCharIndex);
        const text = line.slice(firstCharIndex);

        if (containsHTMLEntity(line)) {
          return `${leftWhitespace}${wrapNonHTMLEntities(text)}`;
        }
        return `${leftWhitespace}{${JSON.stringify(text)}}`;
      }).join('\n');
    }

    /**
     * Report and fix an unnecessary curly brace violation on a node
     * @param {ASTNode} JSXExpressionNode - The AST node with an unnecessary JSX expression
     */
    function reportUnnecessaryCurly(JSXExpressionNode) {
      context.report({
        node: JSXExpressionNode,
<<<<<<< HEAD
        message: 'Curly braces are unnecessary here.',
=======
        messageId: 'unnecessaryCurly',
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
        fix(fixer) {
          const expression = JSXExpressionNode.expression;
          const expressionType = expression.type;
          const parentType = JSXExpressionNode.parent.type;

          let textToReplace;
          if (parentType === 'JSXAttribute') {
<<<<<<< HEAD
            textToReplace = `"${expressionType === 'TemplateLiteral' ?
              expression.quasis[0].value.raw :
              expression.raw.substring(1, expression.raw.length - 1)
=======
            textToReplace = `"${expressionType === 'TemplateLiteral'
              ? expression.quasis[0].value.raw
              : expression.raw.substring(1, expression.raw.length - 1)
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
            }"`;
          } else if (jsxUtil.isJSX(expression)) {
            const sourceCode = context.getSourceCode();

            textToReplace = sourceCode.getText(expression);
          } else {
<<<<<<< HEAD
            textToReplace = expressionType === 'TemplateLiteral' ?
              expression.quasis[0].value.cooked : expression.value;
=======
            textToReplace = expressionType === 'TemplateLiteral'
              ? expression.quasis[0].value.cooked : expression.value;
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
          }

          return fixer.replaceText(JSXExpressionNode, textToReplace);
        }
      });
    }

    function reportMissingCurly(literalNode) {
      context.report({
        node: literalNode,
<<<<<<< HEAD
        message: 'Need to wrap this literal in a JSX expression.',
=======
        messageId: 'missingCurly',
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
        fix(fixer) {
          // If a HTML entity name is found, bail out because it can be fixed
          // by either using the real character or the unicode equivalent.
          // If it contains any line terminator character, bail out as well.
          if (
<<<<<<< HEAD
            containsOnlyHtmlEntities(literalNode.raw) ||
            (literalNode.parent.type === 'JSXAttribute' && containsLineTerminators(literalNode.raw)) ||
            isLineBreak(literalNode.raw)
=======
            containsOnlyHtmlEntities(literalNode.raw)
            || (literalNode.parent.type === 'JSXAttribute' && containsLineTerminators(literalNode.raw))
            || isLineBreak(literalNode.raw)
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
          ) {
            return null;
          }

<<<<<<< HEAD
          const expression = literalNode.parent.type === 'JSXAttribute' ?
            `{"${escapeDoubleQuotes(escapeBackslashes(
              literalNode.raw.substring(1, literalNode.raw.length - 1)
            ))}"}` :
            wrapWithCurlyBraces(literalNode.raw);
=======
          const expression = literalNode.parent.type === 'JSXAttribute'
            ? `{"${escapeDoubleQuotes(escapeBackslashes(
              literalNode.raw.substring(1, literalNode.raw.length - 1)
            ))}"}`
            : wrapWithCurlyBraces(literalNode.raw);
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f

          return fixer.replaceText(literalNode, expression);
        }
      });
    }

    function isWhiteSpaceLiteral(node) {
      return node.type && node.type === 'Literal' && node.value && jsxUtil.isWhiteSpaces(node.value);
    }

    function isStringWithTrailingWhiteSpaces(value) {
      return /^\s|\s$/.test(value);
    }

    function isLiteralWithTrailingWhiteSpaces(node) {
      return node.type && node.type === 'Literal' && node.value && isStringWithTrailingWhiteSpaces(node.value);
    }

    // Bail out if there is any character that needs to be escaped in JSX
    // because escaping decreases readiblity and the original code may be more
    // readible anyway or intentional for other specific reasons
    function lintUnnecessaryCurly(JSXExpressionNode) {
      const expression = JSXExpressionNode.expression;
      const expressionType = expression.type;

<<<<<<< HEAD
      if (
        (expressionType === 'Literal' || expressionType === 'JSXText') &&
          typeof expression.value === 'string' &&
          (
            (JSXExpressionNode.parent.type === 'JSXAttribute' && !isWhiteSpaceLiteral(expression)) ||
            !isLiteralWithTrailingWhiteSpaces(expression)
          ) &&
          !needToEscapeCharacterForJSX(expression.raw) && (
          jsxUtil.isJSX(JSXExpressionNode.parent) ||
          !containsQuoteCharacters(expression.value)
=======
      // Curly braces containing comments are necessary
      if (context.getSourceCode().getCommentsInside(JSXExpressionNode).length > 0) {
        return;
      }

      if (
        (expressionType === 'Literal' || expressionType === 'JSXText')
          && typeof expression.value === 'string'
          && (
            (JSXExpressionNode.parent.type === 'JSXAttribute' && !isWhiteSpaceLiteral(expression))
            || !isLiteralWithTrailingWhiteSpaces(expression)
          )
          && !containsMultilineComment(expression.value)
          && !needToEscapeCharacterForJSX(expression.raw, JSXExpressionNode) && (
          jsxUtil.isJSX(JSXExpressionNode.parent)
          || !containsQuoteCharacters(expression.value)
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
        )
      ) {
        reportUnnecessaryCurly(JSXExpressionNode);
      } else if (
<<<<<<< HEAD
        expressionType === 'TemplateLiteral' &&
          expression.expressions.length === 0 &&
          expression.quasis[0].value.raw.indexOf('\n') === -1 &&
          !isStringWithTrailingWhiteSpaces(expression.quasis[0].value.raw) &&
          !needToEscapeCharacterForJSX(expression.quasis[0].value.raw) && (
          jsxUtil.isJSX(JSXExpressionNode.parent) ||
          !containsQuoteCharacters(expression.quasis[0].value.cooked)
=======
        expressionType === 'TemplateLiteral'
          && expression.expressions.length === 0
          && expression.quasis[0].value.raw.indexOf('\n') === -1
          && !isStringWithTrailingWhiteSpaces(expression.quasis[0].value.raw)
          && !needToEscapeCharacterForJSX(expression.quasis[0].value.raw, JSXExpressionNode) && (
          jsxUtil.isJSX(JSXExpressionNode.parent)
          || !containsQuoteCharacters(expression.quasis[0].value.cooked)
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
        )
      ) {
        reportUnnecessaryCurly(JSXExpressionNode);
      } else if (jsxUtil.isJSX(expression)) {
        reportUnnecessaryCurly(JSXExpressionNode);
      }
    }

    function areRuleConditionsSatisfied(parent, config, ruleCondition) {
      return (
<<<<<<< HEAD
        parent.type === 'JSXAttribute' &&
          typeof config.props === 'string' &&
          config.props === ruleCondition
      ) || (
        jsxUtil.isJSX(parent) &&
          typeof config.children === 'string' &&
          config.children === ruleCondition
=======
        parent.type === 'JSXAttribute'
          && typeof config.props === 'string'
          && config.props === ruleCondition
      ) || (
        jsxUtil.isJSX(parent)
          && typeof config.children === 'string'
          && config.children === ruleCondition
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
      );
    }

    function getAdjacentSiblings(node, children) {
      for (let i = 1; i < children.length - 1; i++) {
        const child = children[i];
        if (node === child) {
          return [children[i - 1], children[i + 1]];
        }
      }
      if (node === children[0] && children[1]) {
        return [children[1]];
      }
      if (node === children[children.length - 1] && children[children.length - 2]) {
        return [children[children.length - 2]];
      }
      return [];
    }

    function hasAdjacentJsxExpressionContainers(node, children) {
      if (!children) {
        return false;
      }
<<<<<<< HEAD
      const childrenExcludingWhitespaceLiteral = children.filter(child => !isWhiteSpaceLiteral(child));
      const adjSiblings = getAdjacentSiblings(node, childrenExcludingWhitespaceLiteral);

      return adjSiblings.some(x => x.type && x.type === 'JSXExpressionContainer');
=======
      const childrenExcludingWhitespaceLiteral = children.filter((child) => !isWhiteSpaceLiteral(child));
      const adjSiblings = getAdjacentSiblings(node, childrenExcludingWhitespaceLiteral);

      return adjSiblings.some((x) => x.type && x.type === 'JSXExpressionContainer');
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    }
    function hasAdjacentJsx(node, children) {
      if (!children) {
        return false;
      }
<<<<<<< HEAD
      const childrenExcludingWhitespaceLiteral = children.filter(child => !isWhiteSpaceLiteral(child));
      const adjSiblings = getAdjacentSiblings(node, childrenExcludingWhitespaceLiteral);

      return adjSiblings.some(x => x.type && arrayIncludes(['JSXExpressionContainer', 'JSXElement'], x.type));
=======
      const childrenExcludingWhitespaceLiteral = children.filter((child) => !isWhiteSpaceLiteral(child));
      const adjSiblings = getAdjacentSiblings(node, childrenExcludingWhitespaceLiteral);

      return adjSiblings.some((x) => x.type && arrayIncludes(['JSXExpressionContainer', 'JSXElement'], x.type));
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    }
    function shouldCheckForUnnecessaryCurly(parent, node, config) {
      // Bail out if the parent is a JSXAttribute & its contents aren't
      // StringLiteral or TemplateLiteral since e.g
      // <App prop1={<CustomEl />} prop2={<CustomEl>...</CustomEl>} />

      if (
<<<<<<< HEAD
        parent.type && parent.type === 'JSXAttribute' &&
        (node.expression && node.expression.type &&
          node.expression.type !== 'Literal' &&
          node.expression.type !== 'StringLiteral' &&
          node.expression.type !== 'TemplateLiteral')
=======
        parent.type && parent.type === 'JSXAttribute'
        && (node.expression && node.expression.type
          && node.expression.type !== 'Literal'
          && node.expression.type !== 'StringLiteral'
          && node.expression.type !== 'TemplateLiteral')
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
      ) {
        return false;
      }

      // If there are adjacent `JsxExpressionContainer` then there is no need,
      // to check for unnecessary curly braces.
      if (jsxUtil.isJSX(parent) && hasAdjacentJsxExpressionContainers(node, parent.children)) {
        return false;
      }
      if (containsWhitespaceExpression(node) && hasAdjacentJsx(node, parent.children)) {
        return false;
      }
      if (
<<<<<<< HEAD
        parent.children &&
        parent.children.length === 1 &&
        containsWhitespaceExpression(node)
=======
        parent.children
        && parent.children.length === 1
        && containsWhitespaceExpression(node)
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
      ) {
        return false;
      }

      return areRuleConditionsSatisfied(parent, config, OPTION_NEVER);
    }

    function shouldCheckForMissingCurly(node, config) {
      if (
<<<<<<< HEAD
        isLineBreak(node.raw) ||
        containsOnlyHtmlEntities(node.raw)
=======
        isLineBreak(node.raw)
        || containsOnlyHtmlEntities(node.raw)
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
      ) {
        return false;
      }
      const parent = node.parent;
      if (
<<<<<<< HEAD
        parent.children &&
        parent.children.length === 1 &&
        containsWhitespaceExpression(parent.children[0])
=======
        parent.children
        && parent.children.length === 1
        && containsWhitespaceExpression(parent.children[0])
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
      ) {
        return false;
      }

      return areRuleConditionsSatisfied(parent, config, OPTION_ALWAYS);
    }

    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------

    return {
      JSXExpressionContainer: (node) => {
        if (shouldCheckForUnnecessaryCurly(node.parent, node, userConfig)) {
          lintUnnecessaryCurly(node);
        }
      },

      'Literal, JSXText': (node) => {
        if (shouldCheckForMissingCurly(node, userConfig)) {
          reportMissingCurly(node);
        }
      }
    };
  }
};
