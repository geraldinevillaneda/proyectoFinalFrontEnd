"use strict";

const validateNames = require("../helpers/validate-names");
<<<<<<< HEAD
const DocumentType = require("../generated/DocumentType");
const Document = require("../generated/Document");
const { HTML_NS, SVG_NS } = require("../helpers/namespaces");

class DOMImplementationImpl {
  constructor(args, privateData) {
    this._ownerDocument = privateData.ownerDocument;
    this._features = Object.create(null);
=======
const { HTML_NS, SVG_NS } = require("../helpers/namespaces");
const { createElement, internalCreateElementNSSteps } = require("../helpers/create-element");
const DocumentType = require("../generated/DocumentType");
const documents = require("../documents.js");

class DOMImplementationImpl {
  constructor(globalObject, args, privateData) {
    this._globalObject = globalObject;
    this._ownerDocument = privateData.ownerDocument;
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
  }

  hasFeature() {
    return true;
  }

  createDocumentType(qualifiedName, publicId, systemId) {
<<<<<<< HEAD
    validateNames.qname(qualifiedName);

    return DocumentType.createImpl([], {
=======
    validateNames.qname(this._globalObject, qualifiedName);

    return DocumentType.createImpl(this._globalObject, [], {
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
      ownerDocument: this._ownerDocument,
      name: qualifiedName,
      publicId,
      systemId
    });
  }

<<<<<<< HEAD
=======
  // https://dom.spec.whatwg.org/#dom-domimplementation-createdocument
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
  createDocument(namespace, qualifiedName, doctype) {
    let contentType = "application/xml";

    if (namespace === HTML_NS) {
      contentType = "application/xhtml+xml";
    } else if (namespace === SVG_NS) {
      contentType = "image/svg+xml";
    }

<<<<<<< HEAD
    const document = Document.createImpl([], {
      options: { contentType, parsingMode: "xml", encoding: "UTF-8" }
=======
    const document = documents.createImpl(this._globalObject, {
      contentType,
      parsingMode: "xml",
      encoding: "UTF-8"
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    });

    let element = null;
    if (qualifiedName !== "") {
<<<<<<< HEAD
      element = document.createElementNS(namespace, qualifiedName);
=======
      element = internalCreateElementNSSteps(document, namespace, qualifiedName, {});
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    }

    if (doctype !== null) {
      document.appendChild(doctype);
    }

    if (element !== null) {
      document.appendChild(element);
    }

<<<<<<< HEAD
    document.origin = this._ownerDocument.origin;
=======
    document._origin = this._ownerDocument._origin;
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f

    return document;
  }

<<<<<<< HEAD
  createHTMLDocument(title) {
    // Let doc be a new document that is an HTML document.
    // Set doc's content type to "text/html".
    const document = Document.createImpl([], {
      options: { parsingMode: "html", encoding: "UTF-8" }
=======
  // https://dom.spec.whatwg.org/#dom-domimplementation-createhtmldocument
  createHTMLDocument(title) {
    // Let doc be a new document that is an HTML document.
    // Set doc's content type to "text/html".
    const document = documents.createImpl(this._globalObject, {
      parsingMode: "html",
      encoding: "UTF-8"
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    });

    // Create a doctype, with "html" as its name and with its node document set
    // to doc. Append the newly created node to doc.
<<<<<<< HEAD
    const doctype = DocumentType.createImpl([], {
      ownerDocument: this,
=======
    const doctype = DocumentType.createImpl(this._globalObject, [], {
      ownerDocument: document,
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
      name: "html",
      publicId: "",
      systemId: ""
    });

    document.appendChild(doctype);

    // Create an html element in the HTML namespace, and append it to doc.
<<<<<<< HEAD
    const htmlElement = document.createElementNS(HTML_NS, "html");
=======
    const htmlElement = createElement(document, "html", HTML_NS);
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    document.appendChild(htmlElement);

    // Create a head element in the HTML namespace, and append it to the html
    // element created in the previous step.
<<<<<<< HEAD
    const headElement = document.createElement("head");
=======
    const headElement = createElement(document, "head", HTML_NS);
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
    htmlElement.appendChild(headElement);

    // If the title argument is not omitted:
    if (title !== undefined) {
      // Create a title element in the HTML namespace, and append it to the head
      // element created in the previous step.
<<<<<<< HEAD
      const titleElement = document.createElement("title");
=======
      const titleElement = createElement(document, "title", HTML_NS);
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
      headElement.appendChild(titleElement);

      // Create a Text node, set its data to title (which could be the empty
      // string), and append it to the title element created in the previous step.
      titleElement.appendChild(document.createTextNode(title));
    }

    // Create a body element in the HTML namespace, and append it to the html
    // element created in the earlier step.
<<<<<<< HEAD
    htmlElement.appendChild(document.createElement("body"));
=======
    const bodyElement = createElement(document, "body", HTML_NS);
    htmlElement.appendChild(bodyElement);
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f

    // doc's origin is an alias to the origin of the context object's associated
    // document, and doc's effective script origin is an alias to the effective
    // script origin of the context object's associated document.

    return document;
  }
<<<<<<< HEAD

  _removeFeature(feature, version) {
    feature = feature.toLowerCase();
    if (this._features[feature]) {
      if (version) {
        const versions = this._features[feature];
        for (let j = 0; j < versions.length; j++) {
          if (versions[j] === version) {
            versions.splice(j, 1);
            return;
          }
        }
      } else {
        delete this._features[feature];
      }
    }
  }

  _addFeature(feature, version) {
    feature = feature.toLowerCase();

    if (version) {
      if (!this._features[feature]) {
        this._features[feature] = [];
      }

      if (version instanceof Array) {
        Array.prototype.push.apply(this._features[feature], version);
      } else {
        this._features[feature].push(version);
      }
    } else {
      this._features[feature] = [];
    }
  }

  _hasFeature(feature, version) {
    feature = feature ? feature.toLowerCase() : "";
    const versions = this._features[feature] || false;

    if (!version && versions.length && versions.length > 0) {
      return true;
    } else if (typeof versions === "string") {
      return versions === version;
    } else if (versions.indexOf && versions.length > 0) {
      for (let i = 0; i < versions.length; i++) {
        const found = versions[i] instanceof RegExp ? versions[i].test(version) : versions[i] === version;
        if (found) {
          return true;
        }
      }
      return false;
    }

    return false;
  }
=======
>>>>>>> b459a022f47e1c55fb538e6c6b01f47908ccd92f
}

module.exports = {
  implementation: DOMImplementationImpl
};
